---
title: "01_Spatial_Analysis"
author: "Matt"
date: "9/10/2020"
output: html_document
---

This document will outline the spatial analyses used in generating figures for my MSc. This code should be reproducible and should work into the future as long as the functions stay the same. First, load libraries and initialize folders.

```{r Load packages and set directories}

suppressMessages(suppressWarnings({
  dt <- "devtools"[!("devtools" %in% installed.packages()[, "Package"])]
  if(length(dt)) install.packages("devtools")
  if(!"devtools" %in% rownames(installed.packages())) install.packages("devtools")
  ls <- c("tidyverse", "bcmaps", "bcdata", "sf", "foreach", "measurements",
          "tabulizer", "mapview", "leaflet")
  new_packages <- ls[!(ls %in% installed.packages()[, "Package"])]
  if(length(new_packages)) install.packages(new_packages)
  sapply(ls, library, character.only = TRUE, quietly = TRUE)[0] 
  if(!webshot::is_phantomjs_installed()) webshot::install_phantomjs()
  rm(ls, new_packages)}))

data_dir <- file.path("./01_Spatial_Data/data")
ldb_maps_dir <- file.path("./01_Spatial_Data/layers/ldb")
bc_maps_dir <- file.path("./01_Spatial_Data/layers/bc")
results_dir <- file.path("./01_Spatial_Data/results")
dir.create(ldb_maps_dir, showWarnings = FALSE, recursive = TRUE)
dir.create(bc_maps_dir, showWarnings = FALSE, recursive = TRUE)
dir.create(results_dir, showWarnings = FALSE)

```

Next, generate a study area of Lac Du Bois from the publicly available BC Parks, Ecological Reserves, and Protected Areas dataset

```{r Lac Du Bois park}

ldb_aoi <- bcdata::bcdc_query_geodata("1130248f-f1a3-4956-8b2e-38d29d3e4af7", crs = 3005) %>% 
  bcdata::filter(PROTECTED_LANDS_NAME %in% c(
    "LAC DU BOIS GRASSLANDS PROTECTED AREA", 
    "MCQUEEN CREEK ECOLOGICAL RESERVE",
    "TRANQUILLE ECOLOGICAL RESERVE")) %>% 
  bcdata::collect() %>% 
  sf::st_union()

ldb_area <- conv_unit(units::drop_units(st_area(ldb_aoi)), "m2", "hectare")

st_write(ldb_aoi, file.path(ldb_maps_dir, "aoi.gpkg"), delete_layer = TRUE, quiet = TRUE)

```

Next, do some BEC work. We want to see the BEC zones within Lac Du Bois park. 
NOTE: The coding here forces a new BEC polygon to be downloaded every time it is ran. To prevent that, change to "force = FALSE", though it doesn't take overly long anyways if you're patient!

```{r BEC Manipulation}

# Lac Du Bois BEC zones and subzones
ldb_bec <- bcmaps::bec(force = TRUE) %>% 
  sf::st_set_agr("constant") %>% 
  sf::st_intersection(ldb_aoi) %>% 
  group_by(ZONE, MAP_LABEL) %>% 
  summarise(do_union = TRUE, .groups = "drop") %>% 
  dplyr::rename(SUBZONE = MAP_LABEL) %>% 
  dplyr::mutate(bgc_area = conv_unit(units::drop_units(st_area(.)), "m2", "hectare")) %>% 
  st_cast("MULTIPOLYGON")

st_write(ldb_bec, file.path(ldb_maps_dir, "bec.gpkg"), delete_layer = TRUE, quiet = TRUE)

```

In this next section, we are going to use the IAPP (Invasive Alien Plant Program) database to find the spotted knapweed polygons in Lac Du Bois. 

```{r LDB IAPP plant sites}

# Download invasive plant boundaries from IAPP within the Lac Du Bois area
ldb_iapp <- bcdata::bcdc_query_geodata("10ecf9ad-1555-4043-834a-f5d24a506d59", crs = 3005) %>% 
  bcdata::filter(bcdata::BBOX(sf::st_bbox(ldb_aoi), crs = 3005)) %>% 
  collect() %>% 
  sf::st_set_agr("constant") %>% 
  {if(nrow(.) > 0) {
    sf::st_intersection(., ldb_aoi)
  } else .} %>% 
  st_cast("MULTIPOLYGON")

# Filter only records containing "SK" label for spotted knapweed
ldb_sk <- dplyr::filter(ldb_iapp, grepl("SK", MAP_LABEL)) %>% 
  st_union()

# Total areas of invasion in Lac Du Bois
ldb_total_invaded_area <- conv_unit(units::drop_units(st_area(st_union(ldb_iapp))), "m2", "hectare")
ldb_total_invaded_perc <- ldb_total_invaded_area / ldb_area * 100
ldb_sk_invaded_area <- conv_unit(units::drop_units(st_area(ldb_sk)), "m2", "hectare")
ldb_sk_invaded_perc <- ldb_sk_invaded_area / ldb_area * 100 # ~13.38%

# Where does spotted knapweed typically invade in Lac Du Bois?
ldb_sk_by_subzone <- sf::st_set_agr(ldb_bec, "constant") %>% 
  sf::st_intersection(ldb_sk) %>% 
  dplyr::mutate(area = conv_unit(units::drop_units(st_area(.)), "m2", "hectare"), 
                ratio = area / bgc_area * 100) %>% 
  dplyr::arrange(desc(area)) %>% 
  st_cast("MULTIPOLYGON")

ldb_sk_by_zone <- dplyr::group_by(ldb_sk_by_subzone, ZONE) %>% 
  dplyr::summarise(area = sum(area), bgc_area = sum(bgc_area), do_union = TRUE,
                   .groups = "drop") %>% 
  dplyr::mutate(ratio = area / bgc_area * 100) %>% 
  dplyr::arrange(desc(area)) %>% 
  st_cast("MULTIPOLYGON")

ldb_stats <- tribble(
  ~stat, ~value, 
  "n_invasive_recordings", nrow(ldb_iapp), 
  "ldb_sk_area_ha", ldb_sk_invaded_area,
  "ldb_sk_perc", ldb_sk_invaded_perc,
  "ldb_invaded_area_ha", ldb_total_invaded_area, 
  "ldb_invaded_perc", ldb_total_invaded_perc,
  "ldb_area", ldb_area,
)

# Write outputs
st_write(ldb_iapp, file.path(ldb_maps_dir, "iapp.gpkg"), delete_layer = TRUE, quiet = TRUE)
st_write(ldb_sk, file.path(ldb_maps_dir, "iapp_sk.gpkg"), delete_layer = TRUE, quiet = TRUE)
st_write(ldb_sk_by_subzone, file.path(ldb_maps_dir, "iapp_sk_by_subzone.gpkg"),
         delete_layer = TRUE, quiet = TRUE)
st_write(ldb_sk_by_zone, file.path(ldb_maps_dir, "iapp_sk_by_zone.gpkg"),
         delete_layer = TRUE, quiet = TRUE)
write.csv(ldb_stats, file.path(results_dir, "ldb_stats.csv"), row.names = FALSE)

```

Spotted knapwweed appears to be most dominant in BG zones in Lac Du Bois, followed by IDF zones. What about throughout BC? Is this consistent with the rest of the province or an artifact of a small sample area?

```{r Provincial BEC and IAPP Analyses}
# This section takes a while because it deals with province wide data.

# Get full IAPP database
bc_iapp <- bcdata::bcdc_query_geodata("10ecf9ad-1555-4043-834a-f5d24a506d59", crs = 3005) %>% 
  collect()

# Select only records containing "SK" in the MAP_LABEL column, and then calculate
# the total area of all polygons. Need to union them because muliple polygons
# overlap with one another, so if total area was calculated per polygon you get
# an overinflated area rather than when they are merged together.
bc_sk <- dplyr::filter(bc_iapp, grepl("SK", MAP_LABEL)) %>% 
  st_union()

# Total area of SK invasion in BC
bc_sk_invaded_area <- conv_unit(units::drop_units(st_area(bc_sk)), "m2", "hectare")
bc_sk_invaded_perc <- bc_sk_invaded_area / bc_area(what = "land", units = "ha") * 100

# Create BEC subzone layer
bc_bgc_subzones <- bec() %>% 
  dplyr::group_by(ZONE, MAP_LABEL) %>% 
  dplyr::summarise(.groups = "drop", do_union = TRUE) %>% 
  dplyr::rename(SUBZONE = MAP_LABEL) %>% 
  dplyr::mutate(bgc_area = conv_unit(units::drop_units(st_area(.)), "m2", "hectare"))

# The IAPP entries have BEC zone info but it's sporadic and incomplete. Instead, 
# get that information from the actual BEC zone boundaries and calculate the 
# percentage of a subzone occupied by SK. THIS TOOK ~5 HOURS TO RUN
bc_sk_by_subzone <- sf::st_set_agr(bc_bgc_subzones, "constant") %>% 
  sf::st_intersection(bc_sk) %>% 
  dplyr::mutate(area = conv_unit(units::drop_units(st_area(.)), "m2", "hectare"), 
                ratio = area / bgc_area * 100) %>% 
  dplyr::arrange(desc(area))

# st_read(file.path(bc_maps_dir, "iapp_sk_by_subzone.gpkg"), quiet = TRUE)

# Much faster to drop geometry column and do simple addition for BEC zone summary
bc_sk_by_zone <- st_drop_geometry(bc_sk_by_subzone) %>% 
  group_by(ZONE) %>% 
  summarise(area = sum(area), bgc_area = sum(bgc_area), .groups = "drop") %>% 
  dplyr::mutate(ratio = area / bgc_area * 100) %>% 
  dplyr::arrange(desc(ratio))

# Save as individual files for faster reading in later on if necessary
st_write(bc_iapp, file.path(bc_maps_dir, "iapp.gpkg"), delete_layer = TRUE, quiet = TRUE)
st_write(bc_sk, file.path(bc_maps_dir, "sk.gpkg"), delete_layer = TRUE, quiet = TRUE)
st_write(bc_bgc_subzones, file.path(bc_maps_dir, "bec.gpkg"), delete_layer = TRUE, quiet = TRUE)
st_write(bc_sk_by_subzone, file.path(bc_maps_dir, "iapp_sk_by_subzone.gpkg"), 
         delete_layer = TRUE, quiet = TRUE)
write.csv(bc_sk_by_zone, file.path(results_dir, "BC_iapp_sk_by_zone.csv"), row.names = FALSE)

```

Some takeaways from the analysis above: 
SK covers ~.056% of the province of BC. That's not overly concerning; however, it does take up ~3% of the BG zone (7891 ha) and 2.46% of the PP zone (7260 ha), with the largest by area invasion happenning in the IDF zone (31,6677 ha), though this zone is very large and only accounts for 0.71% of the entire invaded area. This is important: this implies that the rate of spread in Lac Du Bois park (24%, 1.8%, and 9.1% in respective zones) is generally much higher than the remainder of the province for some reason!

Each zone has very important values for forestry, First Nations, and conservation of endangered species. With that in mind, this process for finding invasive species trends throughout our province should be looked at more seriously. There are currently nearly 160,000 polygons for invasive plant records throughout BC, perhaps we should see where SK falls in terms of how invasive it is in comparison to other plant species. This will require a further investigation into the text of the "MAP_LABEL" column, below:

```{r BC Invasive Plant Metrics}

# Extract plant species column
bc_invasive_plants <- st_drop_geometry(bc_iapp) %>% 
  dplyr::select(MAP_LABEL)

# Get the official plant list from the IAPP, it has species names etc.
bc_iapp_plant_table <- extract_tables(
  "https://delivery.apps.gov.bc.ca/pub/iapp_imf/displayLabelLegend.do", 
  output = "matrix") %>% 
  lapply(function(x) { # Create dataframes from matrix, table headers are in first row
    df <- as.data.frame(x)
    colnames(df) <- df[1, ]
    df <- df[-1, ]
  }) %>% 
  do.call(rbind, args = .) %>% 
  dplyr::rename_with(make.names) %>% 
  dplyr::arrange(Map.Label)
rownames(bc_iapp_plant_table) <- NULL

# Will use the separate function to get columns for different plants, but first
# need to find out what the longest entry is to find how many columns there will be:
n_splits <- max(nchar(str_replace_all(bc_invasive_plants$MAP_LABEL, "[^[:alnum:]]", "")), na.rm = TRUE) / 2
all_plants <- bc_invasive_plants %>% 
  tidyr::separate(MAP_LABEL, into = paste0("sp", 1:n_splits), sep = " ", extra = "drop") %>% 
  apply(MARGIN = 2, FUN = unique) %>% 
  do.call(c, args = .) %>% 
  unique() %>% na.omit() %>% grep("NA", ., invert = TRUE, value = TRUE) %>% sort()

# There are 184 invasive species recorded in BC. Which ones take up the largest
# amount of physical space in BC?
bc_invasive_plant_areas <- foreach(i = 1:length(all_plants), .combine = rbind) %do% {
  cat(paste0("Working on ", all_plants[i], " [", i, " of ", length(all_plants), "]\n"))
  dplyr::filter(bc_iapp, grepl(all_plants[i], MAP_LABEL)) %>% 
    st_union() %>% 
    st_as_sf() %>% 
    dplyr::mutate(Map.Label = all_plants[i], 
                  area = conv_unit(units::drop_units(st_area(.)), "m2", "hectare"))
} %>% dplyr::rename(geometry = x) %>% 
  dplyr::select(Map.Label, area) %>% 
  dplyr::arrange(desc(area)) %>% 
  st_cast("MULTIPOLYGON") %>% 
  merge(bc_iapp_plant_table, all.x = TRUE) %>%
  dplyr::select(c(names(bc_iapp_plant_table), area)) %>% 
  dplyr::arrange(desc(area))
  
# Drop geometry for quick viewing of data
bc_inv_plant_areas_no_geom <- st_drop_geometry(bc_invasive_plant_areas)

# It turns out that spotted and diffuse knapweed are the most invasive plants on
# record in BC (ranked 1 and 2, resepectively)

# This takes ~10-15 minutes
bc_total_invaded_area <- st_union(bc_iapp) %>%
  st_area() %>% 
  units::drop_units() %>% 
  conv_unit("m2", "hectare")

bc_total_invaded_perc <- bc_total_invaded_area / bc_area(what = "land", units = "ha") * 100
sk_of_all_invaded <- bc_sk_invaded_perc / bc_invaded_perc * 100

# BGC zone additional data:
bc_bgc_zone_data <- st_drop_geometry(bc_bgc_subzones) %>% 
  dplyr::group_by(ZONE) %>% 
  dplyr::summarise(area = sum(bgc_area), .groups = "drop") %>% 
  dplyr::mutate(ratio = area / sum(area) * 100) %>% 
  dplyr::arrange(desc(area))

# Concatenate loose results
bc_stats <- tribble(
  ~stat, ~value, 
  "n_invasive_species", length(all_plants), 
  "bc_invaded_ha", bc_total_invaded_area, 
  "bc_invaded_percent", bc_total_invaded_perc, 
  "bc_invaded_SK_ha", bc_sk_invaded_area,
  "bc_invaded_SK_perc", bc_sk_invaded_perc, 
  "bc_invaded_SK_as_ratio_to_area_of_all_invasives", sk_of_all_invaded)

# Write outputs
st_write(bc_invasive_plant_areas, file.path(bc_maps_dir, "iapp_plant_bounds.gpkg"), 
         delete_layer = TRUE, quiet = TRUE)
write.csv(bc_inv_plant_areas_no_geom, file.path(results_dir, "iapp_plant_bounds.csv"), 
          row.names = FALSE)
write.csv(bc_bgc_zone_data, file.path(results_dir, "BC_bec_zone_data.csv"), row.names = FALSE)
write.csv(bc_stats, file.path(results_dir, "BC_stats.csv"), row.names = FALSE)

```

The analysis above shows that SK and DK are the most invasive plants in BC. Additionally, even though only 0.05% of the province is covered in SK, all invasive plants cover only 0.145% of the province, thus SK accounts for slightly more than 1/3 of the invasive plant cover in BC.

Next, I want to pull in the spatial data gathered from field work and see what I can capture from that:

```{r MSC Study area analysis}

msc_map_dir <- file.path("./01_Spatial_Data/layers/study_area")
dir.create(msc_map_dir, showWarnings = FALSE, recursive = TRUE)

unzip(file.path(data_dir, "Matt.kmz"), exdir = tempdir(), overwrite = TRUE)
layers <- st_layers(file.path(tempdir(), "doc.kml"))$name
field_data <- sapply(layers, function(x)
  st_read(file.path(tempdir(), "doc.kml"), layer = x, quiet = TRUE), 
  simplify = FALSE, USE.NAMES = TRUE)
area_of_invasion <- field_data[[which(sapply(field_data, function(x) 
  st_geometry_type(x, by_geometry = FALSE) == "POLYGON"))]] %>% 
  st_transform(3005) %>% 
  st_make_valid()
sample_sites <- field_data[which(sapply(field_data, function(x) 
  st_geometry_type(x, by_geometry = FALSE) == "POINT" && any(grepl("Pri|Inv", x$Name))))] %>% 
  do.call(rbind, .) %>% 
  st_transform(3005) %>% 
  st_make_valid()

# Do some exploration of the spatial data here:
sample_site_exp <- cbind(
  sample_sites, 
  within = st_within(sample_sites, area_of_invasion, sparse = FALSE), 
  distance_to_poly = st_distance(sample_sites, area_of_invasion))
aoi_within <- st_union(area_of_invasion) %>% 
  st_intersection(ldb_sk)
aoi_exp <- area_of_invasion %>% 
  dplyr::mutate(area = st_area(.)) %>% 
  dplyr::mutate(within_iapp_poly = units::drop_units(st_area(aoi_within) / area)) %>% 
  dplyr::mutate(beyond_iapp_poly = 1 - within_iapp_poly) %>% 
  st_drop_geometry() %>% 
  dplyr::select(-Description)

# Write layers separately
st_write(area_of_invasion, file.path(msc_map_dir, "aoi.gpkg"), delete_layer = TRUE,
         quiet = TRUE)
st_write(sample_site_exp, file.path(msc_map_dir, "sample_locations.gpkg"), 
         delete_layer = TRUE, quiet = TRUE)
write.csv(aoi_exp, file.path(results_dir, "study_area_info.csv"), row.names = FALSE)

```

I have all of the necessary shapefiles that I would need. Now, I'd like to create a visually appealing figure for use in my thesis.

```{r Create figures}

fig_dir <- file.path("./01_Spatial_data/figures")
dir.create(fig_dir, showWarnings = FALSE)

sa_trans <- st_geometry(area_of_invasion) %>% st_transform(4326)
ldb_trans <- ldb_aoi %>% st_transform(4326)
ldb_cent <- st_centroid(ldb_aoi) %>% st_transform(4326) %>% st_coordinates()
l <- leaflet() %>% addProviderTiles("OpenTopoMap") %>% 
  addPolygons(data = ldb_trans, color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.5, fillColor = "green") %>% 
  addPolygons(data = ldb_sk %>% st_transform(4326), color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.5, fillColor = "purple") %>% 
  addPolygons(data = sa_trans, color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.5, fillColor = "red") %>% 
  addScaleBar("topright", options = c(metric = TRUE, imperial = FALSE)) %>% 
  addLegend(
    position = "topleft", colors = c("green", "purple"), opacity = 0.7,
    labels = c(htmltools::HTML("Lac Du Bois<br/>Grasslands<br/>Protected Area"), 
               htmltools::HTML("Spotted Knapweed<br/>Invasion (IAPP, 2020)"))
    )

mapshot(l, file = file.path(fig_dir, "ldb.png"), 
        vwidth = 350, vheight = 400,
        remove_controls = c("zoomControl", "layersControl", "homeButton",
                            "drawToolbar", "easyButton"))

##### View of study area

sa_pts <- st_transform(sample_sites, 4326) %>% 
  tidyr::separate(Name, c("Site", "Rep"), remove = FALSE)
sa_cent <- st_centroid(area_of_invasion) %>% st_transform(4326) %>% st_coordinates()

# Get different colored points for inv vs. pri sites
# https://rstudio.github.io/leaflet/markers.html

pal <- colorFactor(c("darkmagenta", "darkgreen"), domain = c("Pri", "Inv"))

addLegendCustom <- function(map, colors, labels, sizes, opacity = 0.5, ...) {
  colorAdditions <- paste0(colors, "; border-radius: 50%; width:", sizes, "px; height:", sizes, "px")
  labelAdditions <- paste0("<div style='display: inline-block;height: ", 
                           sizes, "px;margin-top: 4px;line-height: ", sizes, "px;'>", 
                           labels, "</div>")

  return(addLegend(map, colors = colorAdditions, 
                   labels = labelAdditions, opacity = opacity, ... = ...))
}

s_step <- leaflet() %>% addProviderTiles("OpenTopoMap") %>% 
  addPolygons(data = ldb_trans, color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.5, fillColor = "green") %>% 
  addPolygons(data = ldb_sk %>% st_transform(4326), color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.5, fillColor = "purple") %>% 
  addPolygons(data = sa_trans, color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.8, fillColor = "red") %>% 
  setView(lng = st_coordinates(st_centroid(sa_trans))[ ,"X"], 
          lat = st_coordinates(st_centroid(sa_trans))[ ,"Y"], zoom = 14) %>% 
  addScaleBar("topright", options = c(metric = TRUE, imperial = FALSE))

s <- leaflet() %>% addProviderTiles("OpenTopoMap") %>% 
  addPolygons(data = ldb_trans, color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.5, fillColor = "green") %>% 
  addPolygons(data = ldb_sk %>% st_transform(4326), color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.5, fillColor = "purple") %>% 
  addPolygons(data = sa_trans, color = "black", weight = 2, opacity = 1, 
              fillOpacity = 0.8, fillColor = "red") %>% 
  setView(lng = st_coordinates(st_centroid(sa_trans))[ ,"X"], 
          lat = st_coordinates(st_centroid(sa_trans))[ ,"Y"], zoom = 18) %>% 
  addScaleBar("topright", options = c(metric = TRUE, imperial = FALSE)) %>% 
  addLegend(
    position = "topleft", colors = "red", opacity = 0.8, labels = "Study Area") %>% 
  addLegendCustom(colors = c("darkmagenta", "darkgreen"), labels = c("Invaded", "Pristine"), 
                  sizes = 10, opacity = 1, position = "topleft", title = "Site") %>% 
  addCircleMarkers(data = sa_pts, color = ~pal(Site), stroke = FALSE, 
                   fillOpacity = 1, radius = 5)

# This doesn't work, creates a shiny.tag.list object that doesn't easily output
# to an image.
# s2 <- browsable(
#    tagList(
#       list(
#          tags$head(
#             tags$style(
#                ".leaflet .legend {
#                  line-height: 20px;
#                  font-size: 20px;
#                  font-weight: bold;
#                  font-family: Times New Roman;
#                  }",
#               ".leaflet .legend i{
#                 width: 20px;
#                 height: 20px;
#                  }"
#             )
#          ),
#        s)))
# 
# tag <- plotTag(s2, alt = "", width = 350, height = 400)
# capturePlot(tag, filename = file.path(fig_dir, "study_area_zoom.png"))

mapshot(s_step, file = file.path(fig_dir, "study_area_zoom.png"), 
        vwidth = 350, vheight = 400,
        remove_controls = c("zoomControl", "layersControl", "homeButton",
                            "drawToolbar", "easyButton"))

mapshot(s, file = file.path(fig_dir, "study_area.png"), 
        vwidth = 350, vheight = 400,
        remove_controls = c("zoomControl", "layersControl", "homeButton",
                            "drawToolbar", "easyButton"))

```

Separately, here is some code for finding all range reference areas within a study area (may also include smaller fencing units as well that are used in rangelands). It took a bit of wrangling but this works decently well, I think...

```{r grazing exclosures}
# AKA range reference areas (RRA's)

ldb_rra <- bcdata::bcdc_query_geodata("946b09a4-c63e-48eb-b322-3701c8ba161d", crs = 3005) %>% 
  bcdata::filter(bcdata::BBOX(sf::st_bbox(ldb_aoi), crs = 3005)) %>% 
  collect() %>% 
  sf::st_set_agr("constant") %>% 
  {if(nrow(.) > 0) {
    sf::st_intersection(., ldb_aoi)
  } else .}

# First, fix geometries. Some lines are close to other lines which should be merged
# together. Doing a merge creates duplicate geometries which will be filtered out later
ldb_rra_geom <- st_geometry(ldb_rra)
ldb_rra_geom <- lapply(1:length(ldb_rra_geom), function(xx) {
  x <- ldb_rra_geom[[xx]]
  if(st_geometry_type(x) != "LINESTRING") NULL else {
    ind <- which(st_is_within_distance(st_sfc(x, crs = 3005), ldb_rra_geom, dist = 1, sparse = FALSE))
    ind <- ind[ind != xx]
    ind <- ind[st_geometry_type(ldb_rra_geom[ind]) == "LINESTRING"]
    if(length(ind) > 0) {
      y <- st_union(
        st_sfc(x, crs = 3005), 
        ldb_rra_geom[ind]
      )
      coords <- st_coordinates(y)[, c("X", "Y")]
      if(nrow(coords) >= 5) {
        z <- foreach(i = 1:length(y), .combine = rbind, .final = st_linestring) %do% {
          st_coordinates(y[[i]])[, c("X", "Y")]
        } %>% st_cast("POLYGON")
        if(st_is_valid(z)) z else {
          zz <- st_make_valid(z)
          if(st_geometry_type(zz) == "GEOMETRYCOLLECTION") {
            polys <- st_collection_extract(zz, "POLYGON")
            lines <- st_collection_extract(zz, "LINESTRING")
            if((length(polys) != 1 || st_geometry_type(polys) != "POLYGON") ||
               st_geometry_type(lines) != "LINESTRING") {
              NULL
            } else {
              polys
            }
          } else NULL
        }
      } else NULL
    } else {
      coords <- st_coordinates(x)[, c("X", "Y")]
      if(nrow(coords) >= 5) {
        p1 <- st_point(coords[1, ])
        p2 <- st_point(coords[nrow(coords), ])
        if(st_is_within_distance(p1, p2, 0, sparse = FALSE)) {
          st_cast(x, "POLYGON")
        } else NULL
      } else NULL
    }
  }
})

# Apply new geometries to geometry columns
ldb_rra <- st_set_geometry(ldb_rra, st_sfc(ldb_rra_geom, crs = 3005)) %>% 
  dplyr::filter(!st_is_empty(.))

# Remove duplicated polygons
ldb_rra_geom <- st_geometry(ldb_rra)
ldb_rra_geom <- lapply(1:length(ldb_rra_geom), function(xx) {
  x <- ldb_rra_geom[[xx]]
  sub_geom <- lapply(1:length(ldb_rra_geom), function(yy) {
    if(yy > xx) {
      y <- ldb_rra_geom[[yy]]
      if(x == y) {
        out <- NULL 
      } else out <- x
    } else out <- x
  })
  if(any(sapply(sub_geom, is.null))) NULL else x
})

# Apply new geometries to geometry columns
ldb_rra <- st_set_geometry(ldb_rra, st_sfc(ldb_rra_geom, crs = 3005)) %>% 
  dplyr::filter(!st_is_empty(.))

# Do a size ratio filter, keep the fence for the McQueen Lake ecological reserve, 
# and remove a single offending polygon
area_perim <- data.frame(
  rows = as.numeric(rownames(ldb_rra)),
  id = ldb_rra$id,
  area = st_area(ldb_rra), 
  perim = ldb_rra %>% st_cast("MULTILINESTRING") %>% st_length()
) %>% dplyr::mutate(ratio = as.numeric(area / perim)) %>% 
  dplyr::mutate(ratio = ifelse(grepl("380b|654d", id), 1, ratio), 
                area = ifelse(grepl("380b|654d", id), 1, area)) %>% 
  dplyr::filter(ratio >= 1, ratio < 20, area < 10000, !endsWith(id, c("377b", "2fb", "74ca", "65dd")))

# Filter ldb_rra dataframe using matching rownames from area/perimeter filterings
ldb_rra <- ldb_rra[area_perim$rows, ]

# Write output
st_write(ldb_rra, file.path(ldb_maps_dir, "rras.gpkg"), delete_layer = TRUE, quiet = TRUE)

```

